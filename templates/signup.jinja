{% extends 'base.jinja' %}

{% block content %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sign Up</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }

        .signup-container {
            display: flex;
            width: 800px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            
        }

        .info-section {
            width: 60%;
            padding-right: 20px;
        }

        .form-section {
            width: 40%;
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            
        }

        h1 {
            text-align: center;
            font-size: 24px;
        }

        p {
            margin: 10px 0;
            padding: 10px;
        }

        input {
            width: 90%;
            padding: 10px;
            margin: 5px 0 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        button {
            width: 100%;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        button:hover {
            background-color: #45a049;
        }

        .guide {
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="signup-container">
        <div class="info-section">
            <h2>The best way to communicate</h2>
            <p>Welcome to ChatConnect, the ultimate web chat application designed to enhance your online communication experience. Whether you're looking to connect with friends, participate in lively group discussions, or ensure your conversations are secure.</p>
            <div class="guide">
                <a href="#" onclick="showGuide()">See guide</a>
            </div>
        </div>
        <div class="form-section">
            <h1>Sign Up</h1>
            <p>Quick Sign Up</p>
            <p>Your account name</p>
            <input id="username" />
            <p>Pick a password (4-20 characters)</p>
            <input id="password" type="password" />
            <p>Admin Code</p>
            <input id="adminCode" />
            <button onclick="signup()">Sign Up</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/node-forge/dist/forge.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/crypto-js/crypto-js.js"></script>
    <script>
        // Utility function to check if a URL is valid for redirection
        function isValidURL(string) {
            return string.startsWith("/");
        }

        // Function to handle user sign up
        async function signup() {
            try {
                const username = document.getElementById("username").value;
                const password = document.getElementById("password").value;
                const adminCode = document.getElementById("adminCode").value;

                if (password.length < 4) {
                    alert("Password must be at least 4 characters long.");
                    return;
                }
                if (username.length < 4 || username.length > 20) {
                    alert("Abnormal username length. Please use between 4 and 20 characters.");
                    return;
                }
                const hashedPassword = CryptoJS.SHA256(password).toString();

                // Use PBKDF2 to generate a deterministic "seed" from the password
                const salt = username; // Using the username as the salt
                const key = forge.pkcs5.pbkdf2(password, salt, 1000, 16);

                // Convert the key to a hex string and use it as the seed for PRNG
                const seed = forge.util.bytesToHex(key);

                // Initialize PRNG with the seed
                const prng = forge.random.createInstance();
                prng.seedFileSync = function(needed) {
                    return forge.util.hexToBytes(seed);
                };

                // Generate key pair using the seeded PRNG
                const keypair = forge.pki.rsa.generateKeyPair({bits: 2048, prng: prng});

                // Convert keys to PEM format
                const publicKeyPem = forge.pki.publicKeyToPem(keypair.publicKey);
                const privateKeyPem = forge.pki.privateKeyToPem(keypair.privateKey);

                // Store keys in localStorage with username as part of the key
                localStorage.setItem(username + "_password", password);
                localStorage.setItem(username + "_publicKey", publicKeyPem);
                localStorage.setItem(username + "_privateKey", privateKeyPem);

                // Send the public key to the server with the username, password, and admin code
                const res = await axios.post("{{ url_for('signup_user') }}", {
                    username: username,
                    password: hashedPassword,
                    publicKey: publicKeyPem,
                    : adminCodeadminCode
                });

                if (!isValidURL(res.data)) {
                    alert(res.data); // Display error message from server
                    return;
                }

                // Redirect to the given URL
                window.location.href = res.data;
            } catch (error) {
                console.error("Error during signup", error);
                alert("An error occurred during signup. Please try again.");
            }
        }

        // Function to show guide (dummy function for demonstration)
        function showGuide() {
            alert("This is the sign up guide. Please follow the instructions to sign up. Use a unique username and a strong password between 4 to 20 characters. If you have an admin code, please enter it in the Admin Code field.");
        }
    </script>
</body>
</html>
{% endblock %}r, receiver_username)
        if sender and receiver:
            result = sender.send_request(receiver_username, session)
            session.commit()
            return result
        return "User not found"

def accept_friend_request(sender_username, receiver_username):
    with Session(engine) as session:
        receiver = session.get(User, receiver_username)
        if receiver:
            response = receiver.accept_request(sender_username, session)
            session.commit()
            return response
        return None

def reject_friend_request(sender_username, receiver_username):
    with Session(engine) as session:
        receiver = session.get(User, receiver_username)
        if receiver:
            response = receiver.reject_request(sender_username, session)
            session.commit()
            return response
        return None


def get_friend_requests(username: str) -> List[dict]:
    with Session(engine) as session:
        user = session.get(User, username)
        if user:
            requests = [{'username': name} for name in user.view_requests('received')]
            return requests
        return []

def get_friends_list(username: str):
    with Session(engine) as session:
        user = session.get(User, username)
        if user:
            friends_list = [{'username': friend.username, 'online_status': friend.online_status, 'role': friend.role} for friend in user.friends]
            return friends_list
        return []
    
def set_online_status(username: str, status: bool):
    with Session(engine) as session:
        user = session.query(User).filter_by(username=username).first()
        if user:
            user.online_status = status
            session.commit()

def remove_friend(username: str, friend_username: str) -> str:
    with Session(engine) as session:
        user = session.get(User, username)
        friend = session.get(User, friend_username)
        if user and friend:
            if friend in user.friends:
                user.friends.remove(friend)
                friend.friends.remove(user)
                session.commit()
                return "Friend removed successfully."
            else:
                return "User is not a friend."
        return "User not found."
    
# Insert a staff account after the database is created
def insert_staff_account():
    username = "staff_user"
    password = "staff_password"
    role = "admin"
    if get_user(username) is None:
        # Generate key pair
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
        )
        public_key = private_key.public_key()

        # Convert keys to PEM format
        private_key_pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=serialization.NoEncryption()
        ).decode('utf-8')

        public_key_pem = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        ).decode('utf-8')

        # Store the private key in a secure manner (here we just print it)
        print(f"Private Key (store this securely): {private_key_pem}")

        # First, hash the password using SHA-256
        sha256_hashed_password = sha256(password.encode('utf-8')).hexdigest()

        # Then, hash the SHA-256 hashed password using bcrypt
        hashed_password_twice = bcrypt.hashpw(sha256_hashed_password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

        # Insert user with public key
        print(f"Inserting user {username} with role {role}")
        insert_user(username, hashed_password_twice, public_key_pem, role)

        # Verify insertion by fetching the user and printing details
        user = get_user(username)
        if user:
            print(f"User '{user.username}' inserted successfully.")
            print(f"Public Key: {user.public_key}")
            print(f"Role: {user.role}")
        else:
            print("Failed to insert user.")
    else:
        print(f"User '{username}' already exists.")
        
def mute_user(username: str):
    with Session(engine) as session:
        user = session.get(User, username)
        if user:
            user.ismuted = True
            session.commit()
            return "User muted successfully."
        return "User not found."

def unmute_user(username: str):
    with Session(engine) as session:
        user = session.get(User, username)
        if user:
            user.ismuted = False
            session.commit()
            return "User unmuted successfully."
        return "User not found."


def is_user_muted(username: str) -> bool:
    with Session(engine) as session:
        user = session.get(User, username)
        if user:
            return user.ismuted
        return False

def get_all_users():
    with Session(engine) as session:
        return session.query(User).all()
    
def change_user_role(username, new_role):
    try:
        with Session(engine) as session:
            user = session.query(User).filter_by(username=username).first()
            if user:
                user.role = new_role
                session.commit()
                print(f"Changed role of {username} to {new_role}")
                return True
            else:
                return False
    except Exception as e:
        print(f"Error changing role: {e}")
        return False


# Call the function to insert the staff account
insert_staff_account()